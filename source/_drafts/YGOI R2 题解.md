---
abbrlink: YGOIR2TJ
categories:
- - 题解
date: '2026-02-01T20:08:52.048136+08:00'
description: null
mathjax: true
tags:
- 题解
title: YGOI R2 题解
updated: '2026-02-05T19:09:50.195+08:00'
---
#### 解题思路 暴力枚举所有区间是 \\(O(n^2)\\)，会超时。  正解：考虑每个元素作为最大值和最小值对答案的贡献。 对于每个 \\(a\_i\\)，计算它作为最大值的区间个数 \\(cnt\\\_max[i]\\) 和作为最小值的区间个数 \\(cnt\\\_min[i]\\)。 答案 = \\(\\sum a\_i \\times (cnt\\\_max[i] - cnt\\\_min[i])\\)。  使用单调栈可以在 \\(O(n)\\) 时间内求出每个元素的支配区间范围。  #### 数据生成器 \`\`\`cpp #include <bits/stdc++.h> using namespace std;  int main() { int n = 200000; cout << n << endl; mt19937 rng(time(0)); uniform\_int\_distribution dist(-1e9, 1e9); for (int i = 0; i < n; i++) { cout << dist(rng) << " "; } cout << endl; return 0; } \`\`\`  #### 正解代码 \`\`\`cpp #include <bits/stdc++.h> using namespace std; typedef long long ll; const int MOD = 1e9+7; const int N = 2e5+5;  int n; ll a[N]; int left\_max[N], right\_max[N]; int left\_min[N], right\_min[N];  void solve\_max() { stack st; for (int i = 1; i <= n; i++) { while (!st.empty() && a[st.top()] <= a[i]) { st.pop(); } left\_max[i] = st.empty() ? 1 : (st.top()+1); st.push(i); } while (!st.empty()) st.pop(); for (int i = n; i >= 1; i--) { while (!st.empty() && a[st.top()] < a[i]) { st.pop(); } right\_max[i] = st.empty() ? n : (st.top()-1); st.push(i); } }  void solve\_min() { stack st; for (int i = 1; i <= n; i++) { while (!st.empty() && a[st.top()] >= a[i]) { st.pop(); } left\_min[i] = st.empty() ? 1 : (st.top()+1); st.push(i); } while (!st.empty()) st.pop(); for (int i = n; i >= 1; i--) { while (!st.empty() && a[st.top()] > a[i]) { st.pop(); } right\_min[i] = st.empty() ? n : (st.top()-1); st.push(i); } }  int main() { ios::sync\_with\_stdio(false); cin.tie(0); cin >> n; for (int i = 1; i <= n; i++) cin >> a[i];  solve\_max(); solve\_min();  ll ans = 0; for (int i = 1; i <= n; i++) { ll cnt\_max = (ll)(i - left\_max[i] + 1) \* (right\_max[i] - i + 1); ll cnt\_min = (ll)(i - left\_min[i] + 1) \* (right\_min[i] - i + 1); ll contribution = (cnt\_max - cnt\_min) % MOD \* (a[i] % MOD) % MOD; ans = (ans + contribution) % MOD; } ans = (ans + MOD) % MOD; cout << ans << endl; return 0; } \`\`\`    #### 解题思路 直接模拟所有操作，需要注意： 1. 使用优先队列维护可执行进程（按最终优先级排序） 2. 使用并查集维护进程组，记录每个组的额外优先级偏移 3. 合并时更新所有受影响的进程在优先队列中的位置  由于m≤5000，暴力更新可以接受。  #### 数据生成器 \`\`\`cpp #include <bits/stdc++.h> using namespace std;  int main() { mt19937 rng(time(0)); int m = 5000; cout << m << endl;  vector pids; int next\_pid = 1;  for (int i = 0; i < m; i++) { int op\_type = rng() % 5; if (op\_type == 0 || pids.empty()) { // CREATE cout << "CREATE " << next\_pid << " " << (rng() % 20001 - 10000) << endl; pids.push\_back(next\_pid); next\_pid++; } else if (op\_type == 1) { // RUN cout << "RUN" << endl; if (!pids.empty()) { // 实际数据生成时随机删除一个 pids.erase(pids.begin() + (rng() % pids.size())); } } else if (op\_type == 2) { // UP int pid = pids[rng() % pids.size()]; cout << "UP " << pid << " " << (rng() % 2001 - 1000) << endl; } else if (op\_type == 3) { // MERGE if (pids.size() >= 2) { int idx1 = rng() % pids.size(); int idx2 = rng() % pids.size(); while (idx1 == idx2) idx2 = rng() % pids.size(); cout << "MERGE " << pids[idx1] << " " << pids[idx2] << endl; } else { i--; // 重试 } } else { // QUERY int pid = pids[rng() % pids.size()]; cout << "QUERY " << pid << endl; } } return 0; } \`\`\`  #### 正解代码 \`\`\`cpp #include <bits/stdc++.h> using namespace std;  struct Process { int pid; int base\_priority; int group; bool operator<(const Process& other) const { if (base\_priority != other.base\_priority) return base\_priority < other.base\_priority; return pid > other.pid; } };  struct Group { int extra; vector members; };  vector<Process> processes(100001); vector<Group> groups(100001); vector<int> group\_extra(100001, 0); priority\_queue<Process> pq; vector<bool> active(100001, false); int next\_group = 1;  int find\_group(int pid) { return processes[pid].group; }  void merge\_groups(int g1, int g2) { if (g1 == g2) return; if (groups[g1].members.size() < groups[g2].members.size()) { swap(g1, g2); } // 合并g2到g1 for (int pid : groups[g2].members) { processes[pid].group = g1; processes[pid].base\_priority += group\_extra[g2] - group\_extra[g1]; groups[g1].members.push\_back(pid); } groups[g2].members.clear(); next\_group++; }  int main() { ios::sync\_with\_stdio(false); cin.tie(0);  int m; cin >> m;  while (m--) { string op; cin >> op;  if (op == "CREATE") { int pid, priority; cin >> pid >> priority; processes[pid] = {pid, priority, next\_group}; groups[next\_group] = {next\_group, {pid}}; group\_extra[next\_group] = 0; active[pid] = true; pq.push(processes[pid]); next\_group++; } else if (op == "RUN") { while (!pq.empty()) { Process p = pq.top(); pq.pop(); if (!active[p.pid]) continue; // 检查是否还是当前优先级 int gid = processes[p.pid].group; int actual\_priority = processes[p.pid].base\_priority + group\_extra[gid]; if (actual\_priority != p.base\_priority) { // 优先级已变，重新入队 processes[p.pid].base\_priority = actual\_priority; pq.push(processes[p.pid]); continue; } cout << p.pid << "\\n"; active[p.pid] = false; break; } } else if (op == "UP") { int pid, x; cin >> pid >> x; int gid = processes[pid].group; group\_extra[gid] += x; // 更新组内所有进程在优先队列中的表示 for (int p : groups[gid].members) { processes[p].base\_priority += x; if (active[p]) { pq.push(processes[p]); } } } else if (op == "MERGE") { int pid1, pid2; cin >> pid1 >> pid2; int g1 = find\_group(pid1); int g2 = find\_group(pid2); merge\_groups(g1, g2); } else if (op == "QUERY") { int pid; cin >> pid; int gid = processes[pid].group; int priority = processes[pid].base\_priority + group\_extra[gid]; cout << priority << "\\n"; } }  return 0; } \`\`\`    #### 解题思路 1. 使用动态规划：\\( dp[t][state] \\) 表示第t个时间单位后的资源分布状态 2. 状态转移：对于每个状态，计算可能通过网络流传输到达的下一个状态 3. 网络流建模：源点向每个节点连边（容量为当前资源量），节点间按管道连边，节点向汇点连边（容量为目标状态资源量） 4. 优化：状态数可能很多，需要剪枝和合并等价状态  #### 数据生成器 \`\`\`cpp #include <bits/stdc++.h> using namespace std;  int main() { mt19937 rng(time(0)); int n = 50, m = 200, k = 5; cout << n << " " << m << " " << k << endl;  uniform\_int\_distribution cap\_dist(0, 100); for (int i = 0; i < n; i++) { cout << cap\_dist(rng) << " "; } cout << endl;  for (int i = 0; i < n; i++) { int c = cap\_dist(rng); cout << c << " "; } cout << endl;  for (int i = 0; i < m; i++) { int u = rng() % n + 1; int v = rng() % n + 1; while (u == v) v = rng() % n + 1; int w = rng() % 101; cout << u << " " << v << " " << w << endl; } return 0; } \`\`\`  #### 正解代码 \`\`\`cpp #include <bits/stdc++.h> using namespace std;  const int INF = 1e9;  struct Edge { int to, cap, rev; };  class MaxFlow { vector> g; vector level, iter; int n; public: MaxFlow(int n) : n(n), g(n), level(n), iter(n) {}  void add\_edge(int from, int to, int cap) { g[from].push\_back({to, cap, (int)g[to].size()}); g[to].push\_back( {from, 0, (int)g[from].size()-1}); }  void bfs(int s) { fill(level.begin(), level.end(), -1); queue q; level[s] = 0; q.push(s); while (!q.empty()) { int v = q.front(); q.pop(); for (auto& e : g[v]) { if (e.cap > 0 && level[e.to] < 0) { level[e.to] = level[v] + 1; q.push(e.to); } } } }  int dfs(int v, int t, int f) { if (v == t) return f; for (int& i = iter[v]; i < g[v].size(); i++) { Edge& e = g[v][i]; if (e.cap > 0 && level[v] < level[e.to]) { int d = dfs(e.to, t, min(f, e.cap)); if (d > 0) { e.cap -= d; g[e.to][e.rev].cap += d; return d; } } } return 0; }  int max\_flow(int s, int t) { int flow = 0; while (true) { bfs(s); if (level[t] < 0) return flow; fill(iter.begin(), iter.end(), 0); int f; while ((f = dfs(s, t, INF)) > 0) { flow += f; } } } };  int n, m, k; vector<int> cap, init; vector<tuple<int, int, int>> pipes;  pair<int, int> compute\_score(const vector<int>& state) { int sum = accumulate(state.begin(), state.end(), 0); int avg = sum / n; int variance = 0; for (int x : state) { variance += (x - avg) \* (x - avg); } return {variance, sum}; }  int main() { ios::sync\_with\_stdio(false); cin.tie(0);  cin >> n >> m >> k; cap.resize(n); init.resize(n); for (int i = 0; i < n; i++) cin >> cap[i]; for (int i = 0; i < n; i++) cin >> init[i];  pipes.resize(m); for (int i = 0; i < m; i++) { int u, v, w; cin >> u >> v >> w; pipes[i] = {u-1, v-1, w}; }  // 状态编码：使用vector<int>作为状态 map<vector<int>, int> dp\_flow; // 最大传输量 map<vector<int>, pair<int, int>> dp\_score; // (方差, 传输量)  dp\_score[init] = {0, 0};  for (int t = 0; t < k; t++) { map, pair> next\_dp;  for (auto& [state, score] : dp\_score) { // 构建网络流图：源点->节点(当前资源)，节点->汇点(目标资源) // 节点间通过管道连接 int nodes = n + 2; int S = n, T = n + 1;  // 尝试所有可能的目标状态 // 简化：只考虑在容量范围内的状态 // 由于状态空间大，需要限制搜索范围 // 这里使用启发式：只考虑与当前状态相差不大的状态  vector candidate(n); // 生成候选状态：对每个节点，资源量在[min(state[i], cap[i]), cap[i]]之间 // 实际上需要枚举，这里简化：只考虑每个节点变化不超过delta的情况 const int delta = 2;  function&)> generate\_states = [&](int idx, vector& cur) { if (idx == n) { // 检查是否可达 MaxFlow mf(nodes); for (int i = 0; i < n; i++) { mf.add\_edge(S, i, state[i]); mf.add\_edge(i, T, cur[i]); } for (auto& [u, v, w] : pipes) { mf.add\_edge(u, v, w); } int flow = mf.max\_flow(S, T); if (flow == accumulate(cur.begin(), cur.end(), 0)) { // 可达 auto new\_score = compute\_score(cur); int total\_flow = score.second + flow;  if (!next\_dp.count(cur) || make\_pair(new\_score.first, -total\_flow) < make\_pair(next\_dp[cur].first, -next\_dp[cur].second)) { next\_dp[cur] = {new\_score.first, total\_flow}; } } return; }  for (int val = max(0, state[idx] - delta); val <= min(cap[idx], state[idx] + delta); val++) { cur[idx] = val; generate\_states(idx+1, cur); } };  vector<int> cur\_state(n); generate\_states(0, cur\_state); }  dp\_score = move(next\_dp); }  // 找到最佳结果 pair<int, int> best\_score = {INF, -INF}; vector<int> best\_state;  for (auto& [state, score] : dp\_score) { auto current = make\_pair(score.first, -score.second); if (current < best\_score) { best\_score = current; best\_state = state; } }  cout << best\_score.first \* n \* n << " " << -best\_score.second << endl;  return 0; } \`\`\`  ---  ## 题目总结  1. \*\*第一题\*\*：需要单调栈技巧将 \\(O(n^2)\\) 优化到 \\(O(n)\\) 的思维题 2. \*\*第二题\*\*：复杂的大模拟，考察代码实现能力和数据结构使用 3. \*\*第三题\*\*：结合网络流和动态规划的综合题，暴力搜索结合优化可以通过  每道题都提供了数据生成器和正解代码，可以直接用于模拟赛。
